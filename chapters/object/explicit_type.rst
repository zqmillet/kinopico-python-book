.. _section_implicit_type:

经典的误解
==========

一个非常经典的对于 Python 误解就是认为 Python 是一个弱类型语言. 然而, 事实上, Python 是一门强类型语言. 在解释这个结论之前, 我们需要弄清楚什么是强类型语言, 什么是弱类型语言.

强弱类型有很多区分方式, 讨论到现在也没有一个定论. 但是目前公认的一种区分方式为:

- 如果一门语言很少地进行隐式类型转换, 说明它是强类型语言.
- 如果一门语言经常地进行隐式类型转换, 说明他是弱类型语言.

按照这个定义, Python 无疑是强类型语言, 因为 Python 几乎不会进行隐式类型转换.

.. admonition:: 疑问

    当 Python 执行 :py:`1 + 2.0` 并得到 :py:`3.0` 这个结果时, 难道不是先将 :py:`1` 隐式转换成 :py:`1.0` 然后再进行计算的吗?

这是 C 语言的做法, 并不能想当然的认为 Python 也是这么做的. 事实上, 当 Python 执行 :py:`a + b` 时, 并不关心变量 :py:`a` 和 :py:`b` 的类型, Python 只是单纯的将 :py:`a + b` 解释为 :py:`a.__add__(b)`, 在某些特殊的时候, 也会解释成 :py:`b.__radd__(a)`, 当然, 这个是另一个故事了. 可以看到, Python 在做加法时, 并没有进行类型转换, 而是直接调用变量的成员方法, 在这个过程中, 两个变量的类型都没有发生变化. 从这个意义上来说, Python 的强类型特性比 C 语言还强. 关于 C 语言的隐式类型转换, 可以参考附录中的 :ref:`appendix_implicit_conversion`.

.. admonition:: 疑问

    .. code-block:: Python

        a = '1'
        a = 1 + 3

    在上述代码中, 变量 :py:`a` 的值先是字符串 :py:`'1'`, 然后又变成了整数 :py:`4`, 在运行的过程中, 变量的类型发生了变化, 这不正是弱类型语言的表现吗?

变量 :py:`a` 只是一个指针的名字, 当运行在第一行的时候, 指向的是字符串 :py:`'1'`, 当运行在第二行的时候, 指向的是整数 :py:`4`, 这个过程中也不存在类型的隐式转换.
